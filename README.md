# Ethereum Compiler
Компилятор реализует перевод кода тестового языка F-stroke в машинный код Ethereum Virtual Machine
## Примеры программ
#### Пример 1 - сумма двух чисел, переданных в контракт в качестве параметров
```
( prog ( 
  ( setq x ( read 0 ) )
  ( setq y ( read 1 ) )
  ( return ( plus x y ) ) )
)
```
Результат компиляции: `6000356020350160005260206000F3`\
Команды VM:
```
00: 60 00 PUSH1 0x00
02: 35    CALLDATALOAD
03: 60 20 PUSH1 0x20
05: 35    CALLDATALOAD
06: 01    ADD
07: 60 00 PUSH1 0x00
09: 52    MSTORE
0a: 60 20 PUSH1 0x20
0c: 60 00 PUSH1 0x00
0e: f3    RETURN
```
#### Пример 2 - сумма первых 10 членов арифметической прогрессии
```
( prog ( 
  ( setq sum 0 )
  ( setq i 10 )
  ( while ( nonequal i 0 ) ( 
    ( setq sum ( plus sum i ) ) 
    ( setq i ( minus i 1 ) ) ) 
  )
  ( return sum ) )
)
```
Результат компиляции: `60008052600a602052600c565b60205115602a5760005160205101600052600160205103602052600c565b60206000f3`\
Команды VM:
```
00: 60 00 PUSH1 0x00
02: 80    DUP1
03: 52    MSTORE
04: 60 0a PUSH1 0x0a
06: 60 20 PUSH1 0x20
08: 52    MSTORE
09: 60 0c PUSH1 0x0c
0b: 56    JUMP
0c: 5b    JUMPDEST
0d: 60 20 PUSH1 0x20
0f: 51    MLOAD
10: 15    ISZERO
11: 60 2a PUSH1 0x2a
13: 57    JUMPI
14: 60 00 PUSH1 0x00
16: 51    MLOAD
17: 60 20 PUSH1 0x20
19: 51    MLOAD
1a: 01    ADD
1b: 60 00 PUSH1 0x00
1d: 52    MSTORE
1e: 60 01 PUSH1 0x01
20: 60 20 PUSH1 0x20
22: 51    MLOAD
23: 03    SUB
24: 60 20 PUSH1 0x20
26: 52    MSTORE
27: 60 0c PUSH1 0x0c
29: 56    JUMP
2a: 5b    JUMPDEST
2b: 60 20 PUSH1 0x20
2d: 60 00 PUSH1 0x00
2f: f3    RETURN
```
#### Пример 3 - сумма первых 10 членов арифметической прогрессии с использованием рекурсии
```
( func sum ( x ) (
    ( cond ( equal x 0 )
      ( return 0 )
      ( return ( plus x ( sum ( minus x 1 ) ) ) )
    )
  )
)

( prog ( ( return ( sum 10 ) ) ) )
```
Результат компиляции: `600a6008906011565b60005260206000f35b80158290602357506028600182036011565b909150565b019056`\
Команды VML:
```
00: 60 0a PUSH1 0x0a
02: 60 08 PUSH1 0x08 [A]
04: 90    SWAP1
05: 60 11 PUSH1 0x11 [B]
07: 56    JUMP
08: 5b    JUMPDEST [A]
09: 60 00 PUSH1 0x00
0b: 52    MSTORE
0c: 60 20 PUSH1 0x20
0e: 60 00 PUSH1 0x00
10: f3    RETURN
11: 5b    JUMPDEST [B]
12: 80    DUP1
13: 15    ISZERO
14: 82    DUP3
15: 90    SWAP1
16: 60 23 PUSH1 23 [C]
18: 57    JUMPI
19: 50    POP
1a: 60 28 PUSH1 28 [D]
1c: 60 01 PUSH1 0x01
1e: 82    DUP3
1f: 03    SUB
20: 60 11 PUSH1 0x11 [B]
22: 56    JUMP
23: 5b    JUMPDEST [C]
24: 90    SWAP1
25: 91    SWAP2
26: 50    POP
27: 56    JUMP
28: 5b    JUMPDEST [D]
29: 01    ADD
2a: 90    SWAP1
2b: 56    JUMP
```


## Описание языка F-stroke
F-stroke - язык, поддерживающий функциональную парадигму.
Являясь упрощенной и модифицированной версией языка Lisp, он берет из этого языка базовый синтаксис и семантику.
### Структура программы и определения
Программа на языке F-stroke -- последовательность элементов. Элементы -- это либо атомы (идентификаторы), либо константы, либо списки.

Константа - это заданное в явном виде значение. В языке F-stroke все константы только безнаковые целые числа.

Атомы похожи на переменные в традиционных языках программирования. С атомом ассоциирован идентификатор. Атом может иметь значение. Значение атома -- это либо значение соответствующей константы, либо список.

Списки - это последовательности элементов, разделенные пробелами и заключенные в круглые скобки.

Исполнение программы начинается с самого первого элемента, расположенного точке входа (будет определена позже). Каждый элемент обрабатывается в соответствии со своей семантикой:

Если текущий элемент - атом, используется его значение
Если текущий элемент - список, он обрабатывается как вызов функции, имя которой -- это первый элемент списка, а последующие элементы (если они есть) рассматриваются как аргументы функции.
Некоторые списки имеют специальную назначение. Если список начинается с одного из приведенных ниже ключевого слова, то это называется специальной формой и обрабатывается одним способов описанных далее.

Ключевые слова для специальных форм:

`setq func prog cond while return break`

### Специальные формы
Специальные формы определяют инструментарий языка программирования и поэтому каждая имеет свое собственное поведение. Каждая специальная форма -- список, где первый элмент списка - ключевое слово. Остальная часть специальной формы содержит число элементов, специфичное для каждой формы.
#### ( setq Atom Element )
Эта форма выполняет присваивание значения атому. Сначала обрабатывается третий элемент списка и полученный результат определяет новое значение атома из второго элемента списка, заменяя его предыдущее значение. Если в текущем контексте исполнения нет атома с данным именем, тогда он создается и добавляется в контекст.

Поскольку результатом вычисления формы `setq` целиком является неопределенное значение, то использование формы в составе арифметических или логических операций не допускается.
##### Примеры:
```
( setq x 5 )
( setq y ( plus 1 2 ) ) // atom y gets the value of 3
```
#### ( func Atom List Element )
Эта форма используется для задания определенной пользователем функции. Второй элемент списка становится именем функции. Третий элемент списка должен содержать атомы, которые будут расцениваться, как параметры функции. Четвертый элемент -- тело функции.

Следует отметить, что каждая определенная пользователем функция вводит свой собственный локальный контекст исполнения. Это значит, что атомы, представляющие параметры функции, рассматриваются локальными к функции, также как атомы объявленные `setq` формой. Если `setq` форма объявляет атом с таким же именем, как атом из внешнего контекста, то локально объявленный атом "скрывает" атом из внешнего контекста. Локальный контекст функции пропадает после исполнения функции.

Тело функции может состоять из списка элементов, выраженных также списками. Тогда при выполнении тела функции такие элементы обрабатываются последовательно. 

Результатом исполнения функции будет являться результат последнего обработанного элемента. 

Функция должна быть определена до использования в теле другой функции.

Функция не может входить в тело других форм.

##### Примеры:
```
( func Cube ( arg ) ( times ( times arg arg ) arg ) )
( func One () 1 )
```
```
( func dec ( i ) ( minus i 1 ) )
( func pow ( arg1 arg2 ) (
  ( setq res 1 )
  ( while ( nonequal arg2 0 )
          ( ( setq res ( times res arg1 ) )
            ( setq arg2 ( dec arg2 ) )
          )
  )
  ( return res ) )
)
```
#### ( prog ( List { List } ) )
Эта форма объявляет точку входа, с которой начинается выполнение программы. Во втором элементе списка -- список элементов, которые будут выполняться последовательно.

В программе может быть только одна форма `prog`. Она не может входить в тело других форм.

Самым последним элементом, выполняющимся в форме `prog`, должна быть специальная форма `return`.

Определенные пользователем функции должны быть определены до формы `prog`.

Примеры:
```
( prog ( ( return ( pow ( read 0 ) ) ) )
```
```
( prog ( 
    ( setq v ( read 0 ) )
    ( setq b ( read 1 ) )
    ( setq l ( read 2 ) )
    ( setq res 0 )
    ( while ( equal 1 1 ) (
    	( cond 
            ( equal ( minus v ( times ( divide v b ) b ) ) l ) 
            ( setq res ( plus res 1 ) )
        )
        ( setq v ( divide v b ) )
        ( cond ( equal v 0 ) ( return res ) )        
      )
    )
  )
)
```
#### ( cond List List { List } )
Данная форма - аналог условного оператора в традиционных языках программирования. Она состоит из двух или трех аргументов. Получение результа для этой формы начинается с выполнения функции, вызываемой в первом аргументе. Функция должна вернуть истину или ложь. Если функция вернула истину, то вычисляется второй аргумент. Иначе вычисляется третий аргумент, если он есть. 

Поскольку результатом вычисления формы целиком является неопределенное значение, то использование формы в составе арифметических или логических операций не допускается.
#### ( while List List )
Форма используется для выполнения повторяющихся действий. Сначала вычисляется второй элемент списка. Если результат вычисления истина, тогда вычисляется третий элемент списка, а затем контроль возвращается снова для вычисления второго элемента списка. Иными словами, второй элемент списка вычисляется перед каждой итерацией. Если результат вычисления - ложь, то форма `while` завершается. 

Содержимое третьего элемента списка (если определено также в виде списка) обрабатываются последовательно.

Поскольку результатом вычисления формы целиком является неопределенное значение, то использование формы в составе арифметических или логических операций не допускается.
#### ( return Element )
Эта форма применима только внутри форм `func` и `prog`. Она вычисляет аргумент и прерывает выполнение той формы, внутри которой выполняется.
#### ( break )
Эта форма применима только внутри формы `while`. Она безусловно прерывает выполнение ближайшей формы, в которой выполнилась форма `break`.
### Предопределенные функции
Все предопределенные функции выполняют какие-то действия над переданными аргументами и возвращают какой-то результат. Результатом выполнения предопределенных функций может быть целое число, либо логический тип внутреннего использования (не может быть возвращен из пользовательских функций и формы `prog`). Вызовы функций представлены в виде списков, где первый элемент - атом (идентификатор), определяющий какая функция будет вызвана.

Все предопределенные функции за исключением `not` и `read` принимают по два аргумента. Перед передачей управления в тело функции первым действием вычисляются все аргументы: сначала первый, потом второй.
#### Арифметические операции
* `( plus Element Element )` - складывает два аргумента
* `( minus Element Element )` - вычитает из первого второй аргумент
* `( times Element Element )` - умножает два аргумента
* `( divide Element Element )` - возвращает результат целочисленного деления первого аргумента на второй
#### Сравнение
* `( equal Element Element )` - возвращает истину, если два аргумента равны
* `( nonequal Element Element )` - возвращает истину, если два аргумента не равны
* `( less Element Element )` - возвращает истину, если первый аргумент меньше второго
* `( lesseq Element Element )` - возвращает истину, если первый аргумент меньше либо равен второму
* `( greater Element Element )` - возвращает истину, если первый аргумент больше второго
* `( greatereq Element Element )` - возвращает истину, если первый аргумент больше либо равен второму
Все функции сравнения возвращают логический тип внутреннего использования, который не может быть возвращен из пользовательских функций и формы `prog`.
#### Логические операции
В качестве аргументов данных функций могут быть использованы только результаты функций сравнения или функций, выполняющих логические операции.

* `( and Element Element )` - возвращает истину, если результаты вычисления обоих элементов -- истина
* `( or Element Element )` - возвращает истину, если результат вычисления хотя бы одного из выражений -- истина
* `( not Element )` - возвращает истину, только если результат вычисления элемента -- ложь

Результат функций, выполняющих логические операции, - логический тип внутреннего использования.
#### Получение данных
Специальная функция позволяет получать целое число, которое было передано в качестве параметра при вызова кода контракта:

`( read Element )`

В качестве аргумента данная функция принимает целое число - индекс параметра в передаваемых в контракт данных. Нумерация индексов начинается с 0. Параметр - это всегда безнаковое целое число размерностью в 256 бит.
##### Пример:
`( prog  ( ( return ( plus ( read 0 ) ( read 1 ) ) ) ) )`
Данный контракт вернет сумму двух чисел, которые были переданы ему в качестве параметра.

### Грамматика языка F-stroke
При определении специальных форм и предопределенных функций выше использовались следующие сущности, заданные в грамматике языка F-stroke:

```
Program : Element { Element }
List : ( Element { Element } )
Element : Atom | Literal | List
Atom : Identifier
Literal : Integer
Identifier : Letter { Letter | DecimalDigit }
Letter : Any Unicode character that represents a letter
Integer : DecimalDigit { DecimalDigit }
DecimalDigit : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```
